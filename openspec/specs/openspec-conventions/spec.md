# OpenSpec 约定规范

## 目的

OpenSpec 约定必须定义如何记录系统功能、如何提议和跟踪变更以及规范如何随时间演进。此元规范作为 OpenSpec 自身约定的真实来源。

## 需求
### 需求：用于规范和变更的结构化约定

OpenSpec 约定必须强制执行具有清晰需求和场景部分的结构化规范格式，以便工具可以一致地解析。

#### 场景：遵循结构化规范格式

- **当** 编写或更新 OpenSpec 规范时
- **那么** 作者必须使用 `### Requirement: ...` 后跟至少一个 `#### Scenario: ...` 部分

### 需求：项目结构
OpenSpec 项目必须为规范和变更维护一致的目录结构。

#### 场景：初始化项目结构
- **当** 初始化 OpenSpec 项目时
- **那么** 它必须具有此结构：
```
openspec/
├── project.md              # 项目特定上下文
├── AGENTS.md               # AI 助手指令
├── specs/                  # 当前已部署的功能
│   └── [capability]/       # 单个、专注的功能
│       ├── spec.md         # WHAT 和 WHY
│       └── design.md       # HOW（可选，用于既定模式）
└── changes/                # 提议的变更
    ├── [change-name]/      # 描述性变更标识符
    │   ├── proposal.md     # 原因、内容和影响
    │   ├── tasks.md        # 实现检查清单
    │   ├── design.md       # 技术决策（可选）
    │   └── specs/          # 完整的未来状态
    │       └── [capability]/
    │           └── spec.md # 干净的 markdown（无 diff 语法）
    └── archive/            # 已完成的变更
        └── YYYY-MM-DD-[name]/
```

### 需求：行为规范的结构化格式

行为规范必须使用具有一致部分标题和关键字的结构化格式，以确保视觉一致性和可解析性。

#### 场景：编写需求部分

- **当** 在行为规范中记录需求时
- **那么** 使用格式为 `### Requirement: [Name]` 的 3 级标题
- **并且** 紧接着描述核心行为的 SHALL 语句
- **并且** 保持需求名称具有描述性且少于 50 个字符

#### 场景：记录场景

- **当** 记录特定行为或用例时
- **那么** 使用格式为 `#### Scenario: [Description]` 的 4 级标题
- **并且** 对步骤使用带有粗体关键字的项目符号：
  - **GIVEN** 用于初始状态（可选）
  - **WHEN** 用于条件或触发器
  - **THEN** 用于预期结果
  - **AND** 用于附加结果或条件

#### 场景：添加实现细节

- **当** 一个步骤需要更多细节时
- **那么** 在主要步骤下使用子项目符号
- **并且** 保持一致的缩进
  - 子项目符号提供示例或细节
  - 保持子项目符号简洁

### 需求：基于标题的需求识别

需求标题必须充当唯一标识符，以便在当前规范和提议的变更之间进行程序化匹配。

#### 场景：程序化匹配需求

- **当** 处理增量变更时
- **那么** 使用 `### Requirement: [Name]` 标题作为唯一标识符
- **并且** 使用规范化标题进行匹配：`normalize(header) = trim(header)`
- **并且** 在规范化后比较标题的大小写敏感相等性

#### 场景：处理需求重命名

- **当** 重命名需求时
- **那么** 使用特殊的 `## RENAMED Requirements` 部分
- **并且** 明确指定旧名称和新名称：
  ```markdown
  ## RENAMED Requirements
  - FROM: `### Requirement: Old Name`
  - TO: `### Requirement: New Name`
  ```
- **并且** 如果内容也发生变化，请使用 NEW 标题将其包含在 MODIFIED 下

#### 场景：验证标题唯一性

- **当** 创建或修改需求时
- **那么** 确保规范内不存在重复的标题
- **并且** 验证工具必须将重复标题标记为错误

### 需求：变更存储约定

变更提案必须仅存储对规范的添加、修改和删除，而不是完整的未来状态。

#### 场景：创建带有添加的变更提案

- **当** 创建添加新需求的变更提案时
- **那么** 仅在 `## ADDED Requirements` 下包含新需求
- **并且** 每个需求必须包含其完整内容
- **并且** 对需求和场景使用标准结构化格式

#### 场景：创建带有修改的变更提案

- **当** 创建修改现有需求的变更提案时
- **那么** 在 `## MODIFIED Requirements` 下包含修改后的需求
- **并且** 使用与当前规范中相同的标题文本（规范化）
- **并且** 包含完整的修改后需求（不是 diff）
- **并且** 可选地使用内联注释（如 `← (was X)`）注释更改内容

#### 场景：创建带有删除的变更提案

- **当** 创建删除需求的变更提案时
- **那么** 在 `## REMOVED Requirements` 下列出它们
- **并且** 使用规范化的标题文本进行识别
- **并且** 包含删除原因
- **并且** 记录任何迁移路径（如果适用）

`changes/[name]/specs/` 目录必须包含：
- 仅显示变更内容的增量文件
- ADDED, MODIFIED, REMOVED, 和 RENAMED 需求的部分
- 用于需求识别的规范化标题匹配
- 使用结构化格式的完整需求
- 每个需求的变更类型的清晰指示

#### 场景：使用标准输出符号

- **当** 在 CLI 输出中显示增量操作时
- **那么** 使用这些标准符号：
  - `+` 用于 ADDED（绿色）
  - `~` 用于 MODIFIED（黄色）
  - `-` 用于 REMOVED（红色）
  - `→` 用于 RENAMED（青色）

### 需求：归档流程增强

归档流程必须使用基于标题的匹配以程序化方式将增量变更应用到当前规范。

#### 场景：归档带有增量的变更

- **当** 归档已完成的变更时
- **那么** 归档命令必须：
  1. 首先解析 RENAMED 部分并应用重命名
  2. 解析 REMOVED 部分并通过规范化标题匹配进行删除
  3. 解析 MODIFIED 部分并通过规范化标题匹配进行替换（如果已重命名，则使用新名称）
  4. 解析 ADDED 部分并追加新需求
- **并且** 验证所有 MODIFIED/REMOVED 标题是否存在于当前规范中
- **并且** 验证 ADDED 标题是否尚不存在
- **并且** 在主 specs/ 目录中生成更新的规范

#### 场景：归档期间处理冲突

- **当** 增量变更与当前规范状态冲突时
- **那么** 归档命令必须报告具体冲突
- **并且** 在继续之前要求手动解决
- **并且** 提供解决冲突的清晰指导

### 需求：提案格式

提案必须通过清晰的从/到比较明确记录所有变更。

#### 场景：记录变更

- **当** 记录变更内容时
- **那么** 提案必须明确描述每个变更：

```markdown
**[Section or Behavior Name]**
- From: [current state/requirement]
- To: [future state/requirement]
- Reason: [why this change is needed]
- Impact: [breaking/non-breaking, who's affected]
```

这种显式格式弥补了没有内联 diff 的不足，并确保审阅者确切了解将要更改的内容。

### 需求：变更审查

系统必须支持多种审查提议变更的方法。

#### 场景：审查变更

- **当** 审查提议的变更时
- **那么** 审阅者可以使用以下方式进行比较：
- 提交变更时的 GitHub PR diff 视图
- 命令行：`diff -u specs/[capability]/spec.md changes/[name]/specs/[capability]/spec.md`
- 任何比较当前与未来状态的视觉 diff 工具

### 需求：结构化格式采用

行为规范必须采用带有 `### Requirement:` 和 `#### Scenario:` 标题的结构化格式作为默认格式。

#### 场景：对行为使用结构化标题

- **当** 记录行为需求时
- **那么** 对需求使用 `### Requirement:`
- **并且** 对带有粗体 WHEN/THEN/AND 关键字的场景使用 `#### Scenario:`

### 需求：动词-名词 CLI 命令结构
OpenSpec CLI 设计必须使用动词作为顶级命令，名词作为参数或用于确定范围的标志。

#### 场景：动词优先命令发现
- **当** 用户运行像 `openspec list` 这样的命令时
- **那么** 动词清楚地传达动作
- **并且** 名词通过标志或参数细化范围（例如，`--changes`, `--specs`）

#### 场景：名词命令的向后兼容性
- **当** 用户运行名词前缀命令，如 `openspec spec ...` 或 `openspec change ...`
- **那么** CLI 必须在至少一个版本中继续支持它们
- **并且** 显示指向动词优先替代方案的弃用警告

#### 场景：消歧指导
- **当** 项目名称在变更和规范之间模棱两可时
- **那么** `openspec show` 和 `openspec validate` 必须接受 `--type spec|change`
- **并且** 帮助文本必须清楚地记录这一点

## 核心原则

系统必须遵循这些原则：
- 规范反映当前已构建和部署的内容
- 变更包含关于应该更改内容的建议
- AI 驱动文档流程
- 规范是与部署代码保持同步的活文档

## 目录结构

### 需求：项目结构

OpenSpec 项目必须为规范和变更维护一致的目录结构。

#### 场景：初始化项目结构

- **当** 初始化 OpenSpec 项目时
- **那么** 它必须具有此结构：
```
openspec/
├── project.md              # 项目特定上下文
├── AGENTS.md               # AI 助手指令
├── specs/                  # 当前已部署的功能
│   └── [capability]/       # 单个、专注的功能
│       ├── spec.md         # WHAT 和 WHY
│       └── design.md       # HOW（可选，用于既定模式）
└── changes/                # 提议的变更
    ├── [change-name]/      # 描述性变更标识符
    │   ├── proposal.md     # 原因、内容和影响
    │   ├── tasks.md        # 实现检查清单
    │   ├── design.md       # 技术决策（可选）
    │   └── specs/          # 完整的未来状态
    │       └── [capability]/
    │           └── spec.md # 干净的 markdown（无 diff 语法）
    └── archive/            # 已完成的变更
        └── YYYY-MM-DD-[name]/
```

## 规范格式

### 需求：行为规范的结构化格式

行为规范必须使用具有一致部分标题和关键字的结构化格式，以确保视觉一致性和可解析性。

#### 场景：编写需求部分

- **当** 在行为规范中记录需求时
- **那么** 使用格式为 `### Requirement: [Name]` 的 3 级标题
- **并且** 紧接着描述核心行为的 SHALL 语句
- **并且** 保持需求名称具有描述性且少于 50 个字符

#### 场景：记录场景

- **当** 记录特定行为或用例时
- **那么** 使用格式为 `#### Scenario: [Description]` 的 4 级标题
- **并且** 对步骤使用带有粗体关键字的项目符号：
  - **GIVEN** 用于初始状态（可选）
  - **WHEN** 用于条件或触发器
  - **THEN** 用于预期结果
  - **AND** 用于附加结果或条件

#### 场景：添加实现细节

- **当** 一个步骤需要更多细节时
- **那么** 在主要步骤下使用子项目符号
- **并且** 保持一致的缩进
  - 子项目符号提供示例或细节
  - 保持子项目符号简洁

## 变更存储约定

### 需求：基于标题的需求识别

需求标题必须充当唯一标识符，以便在当前规范和提议的变更之间进行程序化匹配。

#### 场景：程序化匹配需求

- **当** 处理增量变更时
- **那么** 使用 `### Requirement: [Name]` 标题作为唯一标识符
- **并且** 使用规范化标题进行匹配：`normalize(header) = trim(header)`
- **并且** 在规范化后比较标题的大小写敏感相等性

#### 场景：处理需求重命名

- **当** 重命名需求时
- **那么** 使用特殊的 `## RENAMED Requirements` 部分
- **并且** 明确指定旧名称和新名称：
  ```markdown
  ## RENAMED Requirements
  - FROM: `### Requirement: Old Name`
  - TO: `### Requirement: New Name`
  ```
- **并且** 如果内容也发生变化，请使用 NEW 标题将其包含在 MODIFIED 下

#### 场景：验证标题唯一性

- **当** 创建或修改需求时
- **那么** 确保规范内不存在重复的标题
- **并且** 验证工具必须将重复标题标记为错误

### 需求：变更存储约定

变更提案必须仅存储对规范的添加、修改和删除，而不是完整的未来状态。

#### 场景：创建带有添加的变更提案

- **当** 创建添加新需求的变更提案时
- **那么** 仅在 `## ADDED Requirements` 下包含新需求
- **并且** 每个需求必须包含其完整内容
- **并且** 对需求和场景使用标准结构化格式

#### 场景：创建带有修改的变更提案

- **当** 创建修改现有需求的变更提案时
- **那么** 在 `## MODIFIED Requirements` 下包含修改后的需求
- **并且** 使用与当前规范中相同的标题文本（规范化）
- **并且** 包含完整的修改后需求（不是 diff）
- **并且** 可选地使用内联注释（如 `← (was X)`）注释更改内容

#### 场景：创建带有删除的变更提案

- **当** 创建删除需求的变更提案时
- **那么** 在 `## REMOVED Requirements` 下列出它们
- **并且** 使用规范化的标题文本进行识别
- **并且** 包含删除原因
- **并且** 记录任何迁移路径（如果适用）

`changes/[name]/specs/` 目录必须包含：
- 仅显示变更内容的增量文件
- ADDED, MODIFIED, REMOVED, 和 RENAMED 需求的部分
- 用于需求识别的规范化标题匹配
- 使用结构化格式的完整需求
- 每个需求的变更类型的清晰指示

#### 场景：使用标准输出符号

- **当** 在 CLI 输出中显示增量操作时
- **那么** 使用这些标准符号：
  - `+` 用于 ADDED（绿色）
  - `~` 用于 MODIFIED（黄色）
  - `-` 用于 REMOVED（红色）
  - `→` 用于 RENAMED（青色）

### 需求：归档流程增强

归档流程必须使用基于标题的匹配以程序化方式将增量变更应用到当前规范。

#### 场景：归档带有增量的变更

- **当** 归档已完成的变更时
- **那么** 归档命令必须：
  1. 首先解析 RENAMED 部分并应用重命名
  2. 解析 REMOVED 部分并通过规范化标题匹配进行删除
  3. 解析 MODIFIED 部分并通过规范化标题匹配进行替换（如果已重命名，则使用新名称）
  4. 解析 ADDED 部分并追加新需求
- **并且** 验证所有 MODIFIED/REMOVED 标题是否存在于当前规范中
- **并且** 验证 ADDED 标题是否尚不存在
- **并且** 在主 specs/ 目录中生成更新的规范

#### 场景：归档期间处理冲突

- **当** 增量变更与当前规范状态冲突时
- **那么** 归档命令必须报告具体冲突
- **并且** 在继续之前要求手动解决
- **并且** 提供解决冲突的清晰指导

### 需求：提案格式

提案必须通过清晰的从/到比较明确记录所有变更。

#### 场景：记录变更

- **当** 记录变更内容时
- **那么** 提案必须明确描述每个变更：

```markdown
**[Section or Behavior Name]**
- From: [current state/requirement]
- To: [future state/requirement]
- Reason: [why this change is needed]
- Impact: [breaking/non-breaking, who's affected]
```

这种显式格式弥补了没有内联 diff 的不足，并确保审阅者确切了解将要更改的内容。

## 变更生命周期

变更流程必须遵循这些状态：

1. **Propose**：AI 创建带有未来状态规范和显式提案的变更
2. **Review**：人类审查提案和未来状态
3. **Approve**：变更被批准实施
4. **Implement**：遵循 tasks.md 检查清单（可以跨越多个 PR）
5. **Deploy**：变更部署到生产环境
6. **Update**：`specs/` 中的规范更新以匹配部署的现实
7. **Archive**：变更移动到 `archive/YYYY-MM-DD-[name]/`

## 查看变更

### 需求：变更审查

系统必须支持多种审查提议变更的方法。

#### 场景：审查变更

- **当** 审查提议的变更时
- **那么** 审阅者可以使用以下方式进行比较：
- 提交变更时的 GitHub PR diff 视图
- 命令行：`diff -u specs/[capability]/spec.md changes/[name]/specs/[capability]/spec.md`
- 任何比较当前与未来状态的视觉 diff 工具

系统依赖工具生成 diff 而不是存储它们。

## 功能命名

功能必须使用：
- 动词-名词模式（例如，`user-auth`, `payment-capture`）
- 连字符小写名称
- 单一焦点（每个功能一个职责）
- 无嵌套（`specs/` 下的扁平结构）

## 何时变更需要提案

必须为以下情况创建提案：
- 新特性或功能
- 对现有行为的破坏性变更
- 架构或模式变更
- 改变行为的性能优化
- 影响访问模式的安全更新

不需要提案的情况：
- 恢复预期行为的错误修复
- 拼写错误或格式修复
- 非破坏性依赖项更新
- 为现有行为添加测试
- 文档澄清

## 为什么采用这种方法

干净的未来状态存储提供：
- **可读性**：无 diff 语法污染
- **AI 兼容性**：AI 工具理解的标准 markdown
- **简单性**：无需特殊解析或处理
- **工具无关**：任何 diff 工具都可以显示变更
- **清晰意图**：显式提案记录推理

结构化格式增加：
- **视觉一致性**：需求和场景前缀使部分立即可识别
- **可解析性**：一致的结构支持工具和自动化
- **逐步采用**：现有规范可以增量迁移
