# OpenSpec 并行增量修复计划

## 问题摘要
- 活动变更在归档时应用需求级替换。当两个变更触及同一需求时，第二个归档会覆盖第一个并静默丢弃场景（例如，Windsurf 与 Kilo Code 斜杠命令更新）。
- 归档工作流（`src/core/archive.ts:191` 和 `src/core/archive.ts:501`）通过用增量中包含的内容替换整个需求块来重建主规范。增量格式（`src/core/parsers/requirement-blocks.ts:113`）没有基础版本或场景级操作的概念。
- 工具无法检测变更作者的起点与实时规范之间的差异，因此并行开发会在没有警告的情况下破坏真实来源。

## 观察到的失败模式
- 变更 A (`add-windsurf-workflows`) 在 `Slash Command Configuration` 下添加了一个 Windsurf 场景。
- 变更 B (`add-kilocode-workflows`) 在同一需求下添加了一个 Kilo Code 场景，从 Windsurf 之前的规范开始。
- 变更 A 归档后，主规范包含两个场景。
- 当变更 B 归档时，`buildUpdatedSpec` 看到 `Slash Command Configuration` 的 `MODIFIED` 块，并用该变更中发布的四场景变体替换该需求。因为该文件从未了解过 Windsurf，所以 Windsurf 场景消失了。
- 没有警告、diff 或冲突指示符——归档成功完成，现在的真实来源规范遗漏了一个已发布的场景。

## 根本原因
1. **仅替换语义。** `buildUpdatedSpec` 执行需求块的哈希映射替换，无法合并或比较单个场景 (`src/core/archive.ts:455`-`src/core/archive.ts:526`)。
2. **缺少基础指纹。** 变更不会持久化它们所针对的需求内容，因此归档步骤无法判断实时规范是否已分叉。
3. **单级粒度。** 增量语言仅理解需求。即使我们引入了场景级解析，如果没有相应的合并策略，我们仍然会丢失兄弟编辑。
4. **缺乏冲突 UX。** CLI 从不强制贡献者协调并行更新。没有等效的 `git merge`, `git rebase` 或冲突标记。

## 设计目标
- 保留每个已批准的场景，无论归档顺序如何。
- 当实时规范与作者的基础分叉时，检测并阻止投机性归档。
- 提供反映源代码控制最佳实践的确定性、可审查的冲突解决流程。
- 保持创作体验符合人体工程学：增量应保持人类可编辑的 markdown。
- 支持增量采用，以便现有存储库可以向前滚动而不会破坏活动工作。

## 建议的修复：分层修复

### 阶段 0 – 止血（检测和护栏）
1. **在每个变更旁边持久化需求指纹。**
   - 在搭建或验证变更时，为每个 `MODIFIED`/`REMOVED`/`RENAMED` 条目捕获当前需求主体，并将其写入 `changes/<id>/meta.json`。
   - 存储基础需求内容的稳定哈希（例如 SHA-256）和原始文本本身以供以后合并。
2. **归档期间验证指纹。**
   - 在 `buildUpdatedSpec` 改变规范之前，从实时规范重新计算需求哈希。
   - 如果哈希与存储的基础不同，则中止并指示用户进行 rebase。这使得破坏性路径变得不可能。
3. **在 CLI 输出中显示意图。**
   - 显示哪些需求已过时、何时分叉以及哪个变更最后触及了它们。
4. **记录临时手动缓解措施。**
   - 更新 `openspec/AGENTS.md` 和文档，以便贡献者知道每当另一个变更落地时都要重新运行 `openspec change sync`（见阶段 1）。

_结果：_ 我们在制定更丰富的合并故事的同时立即防止数据丢失。

### 阶段 1 – 添加 Rebase 工作流（作者侧合并）
1. **引入 `openspec change sync <id>` (或 `rebase`)。**
   - 读取存储的基础快照、当前规范和作者的增量。
   - 每个需求执行 3 向合并。最初可以接受 markdown 行上的朴素 diff3，因为我们已经对需求大小的块进行操作。
   - 如果合并是干净的，用合并后的文本重写 `MODIFIED` 块并刷新存储的指纹。
   - 发生冲突时，在变更增量内写入冲突标记（类似于 Git），并要求作者在重新运行验证之前手动编辑。
2. **丰富验证器消息。**
   - `openspec validate` 应标记未解决的冲突标记或指纹不匹配，以便错误在工作流早期出现。
3. **可选：** 提供 `--rewrite-scenarios` 助手，合并场景的项目符号列表以减少手动编辑噪音。

_结果：_ 贡献者可以在归档之前安全地将其工作与最新规范协调一致，恢复真正的并行开发。

### 阶段 2 – 增加增量粒度
1. **使用场景级指令扩展增量语言。**
   - 允许嵌套在需求标题下的 `## MODIFIED Requirements` + `## ADDED Scenarios` / `## MODIFIED Scenarios` 部分。
   - 由存储在 `meta.json` 中的稳定场景标识符（显式 ID 或生成的哈希）支持。这使系统能够推理单个场景。
2. **教解析器理解嵌套操作。**
   - 更新 `parseDeltaSpec` 以在需求块之外发出场景级操作。
   - 更新 `buildUpdatedSpec`（或其替代品）以合并场景列表，保留顺序，同时以确定性方式插入新条目。
3. **自动化迁移。**
   - 提供一次性命令，检查每个现有规范，注入场景 ID，并将进行中的变更增量重写为更丰富的格式。
4. **当两个变更编辑相同的场景主体或描述时，继续依赖阶段 1 的 rebase 流程解决冲突。**

_结果：_ 大多数并发更新变得可交换，从而大大降低人工合并的几率。

### 阶段 3 – 结构化规范图（长期）
1. **定义稳定的需求 ID。**
   - 在规范中嵌入 `Requirement ID: <uuid>` 标记，以便重命名和移动可跟踪。
   - 这启用了跨功能引用和更好的 diff 可视化等未来功能。
2. **将规范编辑建模为 AST 上的操作。**
   - 为需求/场景/元数据构建中间表示 (IR)。
   - 使用操作转换或类似 CRDT 的技术来保证合并结合性。
3. **直接与 Git 集成。**
   - 提供可选的 `openspec branch` 搭建，使规范变更与 Git 分支对齐，让团队利用 Git 的冲突编辑器处理 markdown IR。

_结果：_ OpenSpec 从基于替换的更新升级为弹性、意图保留的规范管理平台。

## 迁移和产品影响
- **回填元数据：** 在初始推出期间为所有活动变更和当前主规范添加哈希。
- **CLI UX：** 新命令（`change sync`，增强的 `archive`）需要文档、帮助文本和发布说明。
- **文档和 AGENTS 更新：** 强化 rebase 工作流并向 AI 助手解释冲突解决。
- **测试：** 引入覆盖分歧需求指纹和合并解决逻辑的夹具。
- **遥测（可选）：** 记录指纹不匹配，以便我们了解团队在推出后遇到冲突的频率。

## 开放问题 / 风险
- 当多个变更在不同点插入时，我们应该如何对场景进行排序？（考虑可选的 `position` 元数据或确定性字母回退。）
- 如果贡献者删除 `meta.json` 文件，优雅的失败模式是什么？（CLI 应按需重新创建指纹。）
- 我们是否需要支持无法在归档前轻松重新运行 sync 命令的离线作者？（用于紧急情况的潜在 `--accept-outdated` 逃生舱。）
- 如何处理归档的历史变更？我们可能需要迁移脚本来追溯嵌入指纹，以便重新验证成功。

## 立即的下一步
1. 在 `openspec change validate` 期间原型化指纹捕获，并在不匹配时阻止归档。
2. 发布带有基于行的 diff3 合并和冲突标记的 `openspec change sync`。
3. 更新贡献者文档和 AI 指令，强制在归档前运行 `sync`。
4. 作为后续 RFC 规划场景级增量扩展和迁移路径。
