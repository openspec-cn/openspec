# OPSX 工作流 (OPSX Workflow)

> 欢迎在 [Discord](https://discord.gg/YctCnvvshC) 上反馈。

## 它是什么？

OPSX 现在是 OpenSpec 的标准工作流。

它是 OpenSpec 变更的一种**流畅、迭代的工作流**。不再有死板的阶段——只有你可以随时采取的动作。

## 为什么存在

旧版 OpenSpec 工作流虽然有效，但是是**锁定**的：

- **指令是硬编码的** — 埋在 TypeScript 中，你无法更改它们
- **全有或全无** — 一个大命令创建所有东西，无法测试单独的部分
- **固定结构** — 每个人的工作流都一样，无法定制
- **黑盒** — 当 AI 输出不佳时，你无法调整提示词

**OPSX 打开了它。** 现在任何人都可以：

1. **试验指令** — 编辑模板，看 AI 是否做得更好
2. **细粒度测试** — 独立验证每个工件的指令
3. **定制工作流** — 定义你自己的工件和依赖关系
4. **快速迭代** — 更改模板，立即测试，无需重新构建

```
Legacy workflow:                      OPSX:
┌────────────────────────┐           ┌────────────────────────┐
│  Hardcoded in package  │           │  schema.yaml           │◄── 你编辑这个
│  (can't change)        │           │  templates/*.md        │◄── 或者这个
│        ↓               │           │        ↓               │
│  Wait for new release  │           │  Instant effect        │
│        ↓               │           │        ↓               │
│  Hope it's better      │           │  Test it yourself      │
└────────────────────────┘           └────────────────────────┘
```

**这是为每个人准备的：**
- **团队** — 创建符合你们实际工作方式的工作流
- **高级用户** — 调整提示词以获得针对你的代码库的更好 AI 输出
- **OpenSpec 贡献者** — 试验新方法而无需发布版本

我们都在学习什么是最有效的。OPSX 让我们一起学习。

## 用户体验

**线性工作流的问题：**
你处于“规划阶段”，然后是“实施阶段”，然后是“完成”。但实际工作不是那样进行的。你实施了一些东西，意识到你的设计是错的，需要更新规范，继续实施。线性阶段与实际工作方式相冲突。

**OPSX 方法：**
- **动作，而不是阶段** — 创建、实施、更新、归档 — 随时做任何事
- **依赖是推动者** — 它们显示什么是可能的，而不是下一步必须做什么

```
  proposal ──→ specs ──→ design ──→ tasks ──→ implement
```

## 设置

```bash
# 确保你已安装 openspec — 技能是自动生成的
openspec init
```

这会在 `.claude/skills/`（或等效目录）中创建 AI 编码助手自动检测到的技能。

在设置过程中，系统会提示你创建**项目配置** (`openspec/config.yaml`)。这是可选的，但建议创建。

## 项目配置

项目配置允许你设置默认值并将特定于项目的上下文注入到所有工件中。

### 创建配置

配置在 `openspec init` 期间创建，或者手动创建：

```yaml
# openspec/config.yaml
schema: spec-driven

context: |
  Tech stack: TypeScript, React, Node.js
  API conventions: RESTful, JSON responses
  Testing: Vitest for unit tests, Playwright for e2e
  Style: ESLint with Prettier, strict TypeScript

rules:
  proposal:
    - Include rollback plan
    - Identify affected teams
  specs:
    - Use Given/When/Then format for scenarios
  design:
    - Include sequence diagrams for complex flows
```

### 配置字段

| 字段 | 类型 | 描述 |
|-------|------|-------------|
| `schema` | string | 新变更的默认模式 (例如 `spec-driven`) |
| `context` | string | 注入到所有工件指令中的项目上下文 |
| `rules` | object | 按工件规则，以工件 ID 为键 |

### 工作原理

**模式优先级** (从高到低)：
1. CLI 标志 (`--schema <name>`)
2. 变更元数据 (变更目录中的 `.openspec.yaml`)
3. 项目配置 (`openspec/config.yaml`)
4. 默认 (`spec-driven`)

**上下文注入：**
- 上下文被前置到每个工件的指令中
- 包裹在 `<context>...</context>` 标签中
- 帮助 AI 理解你的项目约定

**规则注入：**
- 规则仅注入到匹配的工件中
- 包裹在 `<rules>...</rules>` 标签中
- 出现在上下文之后，模板之前

### 按模式的工件 ID

**spec-driven** (默认):
- `proposal` — 变更提案
- `specs` — 规范
- `design` — 技术设计
- `tasks` — 实施任务

### 配置验证

- `rules` 中的未知工件 ID 会产生警告
- 模式名称会针对可用模式进行验证
- 上下文有 50KB 的大小限制
- 无效的 YAML 会报告行号

### 故障排除

**"Unknown artifact ID in rules: X"**
- 检查工件 ID 是否与你的模式匹配（见上表）
- 运行 `openspec schemas --json` 查看每个模式的工件 ID

**配置未应用：**
- 确保文件位于 `openspec/config.yaml`（不是 `.yml`）
- 使用验证器检查 YAML 语法
- 配置更改立即生效（无需重启）

**上下文太大：**
- 上下文限制为 50KB
- 总结或链接到外部文档代替

## 命令

| 命令 | 作用 |
|---------|--------------|
| `/opsx:explore` | 思考想法，调查问题，澄清需求 |
| `/opsx:new` | 开始一个新的变更 |
| `/opsx:continue` | 创建下一个工件（基于已就绪的内容） |
| `/opsx:ff` | 快进 — 一次性创建所有规划工件 |
| `/opsx:apply` | 实施任务，根据需要更新工件 |
| `/opsx:sync` | 同步增量规范到主规范（可选——如果需要归档提示） |
| `/opsx:archive` | 完成时归档 |

## 用法

### 探索想法
```
/opsx:explore
```
思考想法，调查问题，比较选项。不需要结构——只是一个思维伙伴。当见解清晰时，过渡到 `/opsx:new` 或 `/opsx:ff`。

### 开始新变更
```
/opsx:new
```
系统会问你想构建什么以及使用哪个工作流模式。

### 创建工件
```
/opsx:continue
```
根据依赖关系显示已就绪可创建的内容，然后创建一个工件。重复使用以增量构建你的变更。

```
/opsx:ff add-dark-mode
```
一次性创建所有规划工件。当你对要构建的内容有清晰的图景时使用。

### 实施 (流畅部分)
```
/opsx:apply
```
执行任务，边做边勾选。如果你同时处理多个变更，可以运行 `/opsx:apply <name>`；否则它应该从对话中推断，如果无法判断则提示你选择。

### 完成
```
/opsx:archive   # 完成时移动到归档（如果需要，提示同步规范）
```

## 何时更新 vs. 重新开始

你总是可以在实施之前编辑你的 proposal 或 specs。但是，什么时候完善变成了“这是不同的工作”？

### 提案捕捉了什么

提案定义了三件事：
1. **意图** — 你在解决什么问题？
2. **范围** — 什么是界内/界外的？
3. **方法** — 你将如何解决它？

问题是：哪一个变了，变了多少？

### 在以下情况下更新现有变更：

**意图相同，执行更精细**
- 你发现了没考虑到的边缘情况
- 方法需要微调，但目标不变
- 实施揭示设计略有偏差

**范围缩小**
- 你意识到完整范围太大，想先发布 MVP
- "增加暗黑模式" → "增加暗黑模式切换（v2 中支持系统偏好）"

**学习驱动的修正**
- 代码库结构不是你想象的那样
- 依赖项工作不符合预期
- "使用 CSS 变量" → "改用 Tailwind 的 dark: 前缀"

### 在以下情况下开始新变更：

**意图发生了根本变化**
- 问题本身现在不同了
- "增加暗黑模式" → "增加带有自定义颜色、字体、间距的全面主题系统"

**范围爆炸**
- 变更增长太多，本质上是不同的工作
- 更新后原始提案将面目全非
- "修复登录 Bug" → "重写认证系统"

**原始变更是可完成的**
- 原始变更可以标记为“完成”
- 新工作独立存在，不是完善
- 完成“增加暗黑模式 MVP” → 归档 → 新变更“增强暗黑模式”

### 启发式方法

```
                        ┌─────────────────────────────────────┐
                        │     这是同样的工作吗？              │
                        └──────────────┬──────────────────────┘
                                       │
                    ┌──────────────────┼──────────────────┐
                    │                  │                  │
                    ▼                  ▼                  ▼
             意图相同？        >50% 重叠？        原始变更能在
             问题相同？        范围相同？         没有这些更改
                    │                  │          的情况下“完成”吗？
                    │                  │                  │
          ┌────────┴────────┐  ┌──────┴──────┐   ┌───────┴───────┐
          │                 │  │             │   │               │
         YES               NO YES           NO  NO              YES
          │                 │  │             │   │               │
          ▼                 ▼  ▼             ▼   ▼               ▼
       UPDATE            NEW  UPDATE       NEW  UPDATE          NEW
```

| 测试 | 更新 | 新变更 |
|------|--------|------------|
| **身份** | "同样的事，更精细" | "不同的工作" |
| **范围重叠** | >50% 重叠 | <50% 重叠 |
| **完成** | 没有更改无法“完成” | 可以完成原始变更，新工作独立 |
| **故事** | 更新链讲述连贯的故事 | 补丁会让人困惑而不是澄清 |

### 原则

> **更新保留上下文。新变更提供清晰度。**
>
> 当你思考的历史有价值时选择更新。
> 当重新开始比打补丁更清晰时选择新变更。

把它想象成 git 分支：
- 在处理同一个功能时保持提交
- 当它是真正的新工作时开始一个新分支
- 有时合并部分功能并为第二阶段重新开始

## 有什么不同？

| | 旧版 (`/openspec:proposal`) | OPSX (`/opsx:*`) |
|---|---|---|
| **结构** | 一个大提案文档 | 具有依赖关系的离散工件 |
| **工作流** | 线性阶段：计划 → 实施 → 归档 | 流畅动作 — 随时做任何事 |
| **迭代** | 回退很笨拙 | 边学边更新工件 |
| **定制化** | 固定结构 | 模式驱动（定义你自己的工件） |

**关键见解：** 工作不是线性的。OPSX 不再假装它是线性的。

## 架构深入解析

本节解释 OPSX 如何在底层工作，以及它与旧工作流的对比。

### 理念：阶段 vs 动作

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                         旧版工作流                                           │
│                    (阶段锁定，全有或全无)                                    │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│   ┌──────────────┐      ┌──────────────┐      ┌──────────────┐             │
│   │   PLANNING   │ ───► │ IMPLEMENTING │ ───► │   ARCHIVING  │             │
│   │    PHASE     │      │    PHASE     │      │    PHASE     │             │
│   └──────────────┘      └──────────────┘      └──────────────┘             │
│         │                     │                     │                       │
│         ▼                     ▼                     ▼                       │
│   /openspec:proposal   /openspec:apply      /openspec:archive              │
│                                                                             │
│   • 一次性创建所有工件                                                     │
│   • 实施期间无法回去更新规范                                               │
│   • 阶段门控强制线性推进                                                   │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘


┌─────────────────────────────────────────────────────────────────────────────┐
│                            OPSX 工作流                                       │
│                      (流畅动作，迭代式)                                     │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│              ┌────────────────────────────────────────────┐                 │
│              │           动作 (不是阶段)                  │                 │
│              │                                            │                 │
│              │   new ◄──► continue ◄──► apply ◄──► archive │                 │
│              │    │          │           │           │    │                 │
│              │    └──────────┴───────────┴───────────┘    │                 │
│              │              任意顺序                      │                 │
│              └────────────────────────────────────────────┘                 │
│                                                                             │
│   • 一次创建一个工件 或 快进                                               │
│   • 实施期间更新 specs/design/tasks                                        │
│   • 依赖推动进度，阶段不存在                                               │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘
```

### 组件架构

**旧版工作流** 使用 TypeScript 中的硬编码模板：

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                      旧版工作流组件                                          │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│   硬编码模板 (TypeScript 字符串)                                            │
│                    │                                                        │
│                    ▼                                                        │
│   配置器 (18+ 类，每个编辑器一个)                                           │
│                    │                                                        │
│                    ▼                                                        │
│   生成的命令文件 (.claude/commands/openspec/*.md)                           │
│                                                                             │
│   • 固定结构，无工件感知                                                    │
│   • 更改需要修改代码 + 重新构建                                             │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘
```

**OPSX** 使用外部模式和依赖图引擎：

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                         OPSX 组件                                            │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│   模式定义 (YAML)                                                           │
│   ┌─────────────────────────────────────────────────────────────────────┐   │
│   │  name: spec-driven                                                  │   │
│   │  artifacts:                                                         │   │
│   │    - id: proposal                                                   │   │
│   │      generates: proposal.md                                         │   │
│   │      requires: []              ◄── 依赖                             │   │
│   │    - id: specs                                                      │   │
│   │      generates: specs/**/*.md  ◄── Glob 模式                        │   │
│   │      requires: [proposal]      ◄── proposal 后启用                  │   │
│   └─────────────────────────────────────────────────────────────────────┘   │
│                    │                                                        │
│                    ▼                                                        │
│   工件图引擎                                                                │
│   ┌─────────────────────────────────────────────────────────────────────┐   │
│   │  • 拓扑排序 (依赖排序)                                              │   │
│   │  • 状态检测 (文件系统存在性)                                        │   │
│   │  • 丰富的指令生成 (模板 + 上下文)                                   │   │
│   └─────────────────────────────────────────────────────────────────────┘   │
│                    │                                                        │
│                    ▼                                                        │
│   技能文件 (.claude/skills/openspec-*/SKILL.md)                             │
│                                                                             │
│   • 跨编辑器兼容 (Claude Code, Cursor, Windsurf)                            │
│   • 技能查询 CLI 获取结构化数据                                             │
│   • 通过模式文件完全可定制                                                  │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘
```

### 依赖图模型

工件形成有向无环图 (DAG)。依赖是**推动者**，而不是门控：

```
                              proposal
                             (根节点)
                                  │
                    ┌─────────────┴─────────────┐
                    │                           │
                    ▼                           ▼
                 specs                       design
              (依赖:                      (依赖:
               proposal)                   proposal)
                    │                           │
                    └─────────────┬─────────────┘
                                  │
                                  ▼
                               tasks
                           (依赖:
                           specs, design)
                                  │
                                  ▼
                          ┌──────────────┐
                          │  实施阶段     │
                          │ (依赖:        │
                          │  tasks)      │
                          └──────────────┘
```

**状态转换：**

```
   BLOCKED ────────────────► READY ────────────────► DONE
      │                        │                       │
   缺少依赖                  所有依赖                文件存在于
                             已完成                  文件系统中
```

### 信息流

**旧版工作流** — 代理接收静态指令：

```
  User: "/openspec:proposal"
           │
           ▼
  ┌─────────────────────────────────────────┐
  │  静态指令:                               │
  │  • Create proposal.md                   │
  │  • Create tasks.md                      │
  │  • Create design.md                     │
  │  • Create specs/<capability>/spec.md    │
  │                                         │
  │  不知道什么已存在或                       │
  │  工件之间的依赖关系                       │
  └─────────────────────────────────────────┘
           │
           ▼
  代理一次性创建所有工件
```

**OPSX** — 代理查询丰富的上下文：

```
  User: "/opsx:continue"
           │
           ▼
  ┌──────────────────────────────────────────────────────────────────────────┐
  │  第 1 步: 查询当前状态                                                    │
  │  ┌────────────────────────────────────────────────────────────────────┐  │
  │  │  $ openspec status --change "add-auth" --json                      │  │
  │  │                                                                    │  │
  │  │  {                                                                 │  │
  │  │    "artifacts": [                                                  │  │
  │  │      {"id": "proposal", "status": "done"},                         │  │
  │  │      {"id": "specs", "status": "ready"},      ◄── 第一个就绪       │  │
  │  │      {"id": "design", "status": "ready"},                          │  │
  │  │      {"id": "tasks", "status": "blocked", "missingDeps": ["specs"]}│  │
  │  │    ]                                                               │  │
  │  │  }                                                                 │  │
  │  └────────────────────────────────────────────────────────────────────┘  │
  │                                                                          │
  │  第 2 步: 获取就绪工件的丰富指令                                          │
  │  ┌────────────────────────────────────────────────────────────────────┐  │
  │  │  $ openspec instructions specs --change "add-auth" --json          │  │
  │  │                                                                    │  │
  │  │  {                                                                 │  │
  │  │    "template": "# Specification\n\n## ADDED Requirements...",      │  │
  │  │    "dependencies": [{"id": "proposal", "path": "...", "done": true}│  │
  │  │    "unlocks": ["tasks"]                                            │  │
  │  │  }                                                                 │  │
  │  └────────────────────────────────────────────────────────────────────┘  │
  │                                                                          │
  │  第 3 步: 读取依赖 → 创建一个工件 → 显示解锁了什么                        │
  │  └──────────────────────────────────────────────────────────────────────────┘
```

### 迭代模型

**旧版工作流** — 迭代很笨拙：

```
  ┌─────────┐     ┌─────────┐     ┌─────────┐
  │/proposal│ ──► │ /apply  │ ──► │/archive │
  └─────────┘     └─────────┘     └─────────┘
       │               │
       │               ├── "等等，设计错了"
       │               │
       │               ├── 选项:
       │               │   • 手动编辑文件（破坏上下文）
       │               │   • 放弃并重新开始
       │               │   • 硬着头皮做，以后再修
       │               │
       │               └── 没有官方的“回退”机制
       │
       └── 一次性创建所有工件
```

**OPSX** — 自然迭代：

```
  /opsx:new ───► /opsx:continue ───► /opsx:apply ───► /opsx:archive
      │                │                  │
      │                │                  ├── "设计错了"
      │                │                  │
      │                │                  ▼
      │                │            只需编辑 design.md
      │                │            然后继续！
      │                │                  │
      │                │                  ▼
      │                │         /opsx:apply 从你
      │                │         离开的地方继续
      │                │
      │                └── 创建一个工件，显示解锁了什么
      │
      └── 搭建变更，等待指示
```

### 自定义模式

使用模式管理命令创建自定义工作流：

```bash
# 从头创建一个新模式（交互式）
openspec schema init my-workflow

# 或者 Fork 一个现有模式作为起点
openspec schema fork spec-driven my-workflow

# 验证你的模式结构
openspec schema validate my-workflow

# 查看模式从哪里解析（用于调试）
openspec schema which my-workflow
```

模式存储在 `openspec/schemas/`（项目本地，版本控制）或 `~/.local/share/openspec/schemas/`（用户全局）中。

**模式结构：**
```
openspec/schemas/research-first/
├── schema.yaml
└── templates/
    ├── research.md
    ├── proposal.md
    └── tasks.md
```

**示例 schema.yaml:**
```yaml
name: research-first
artifacts:
  - id: research        # 在 proposal 之前添加
    generates: research.md
    requires: []

  - id: proposal
    generates: proposal.md
    requires: [research]  # 现在依赖 research

  - id: tasks
    generates: tasks.md
    requires: [proposal]
```

**依赖图：**
```
   research ──► proposal ──► tasks
```

### 总结

| 方面 | 旧版 | OPSX |
|--------|----------|------|
| **模板** | 硬编码 TypeScript | 外部 YAML + Markdown |
| **依赖** | 无 (一次性所有) | 带拓扑排序的 DAG |
| **状态** | 基于阶段的心智模型 | 文件系统存在性 |
| **定制化** | 编辑源码，重新构建 | 创建 schema.yaml |
| **迭代** | 阶段锁定 | 流畅，编辑任何东西 |
| **编辑器支持** | 18+ 配置器类 | 单个技能目录 |

## 模式

模式定义了存在哪些工件及其依赖关系。当前可用：

- **spec-driven** (默认): proposal → specs → design → tasks

```bash
# 列出可用模式
openspec schemas

# 查看所有模式及其解析来源
openspec schema which --all

# 交互式创建新模式
openspec schema init my-workflow

# Fork 现有模式以进行定制
openspec schema fork spec-driven my-workflow

# 使用前验证模式结构
openspec schema validate my-workflow
```

## 技巧

- 在致力于变更之前，使用 `/opsx:explore` 思考想法
- 当你知道你想要什么时用 `/opsx:ff`，探索时用 `/opsx:continue`
- 在 `/opsx:apply` 期间，如果有什么不对 — 修复工件，然后继续
- 任务通过 `tasks.md` 中的复选框跟踪进度
- 随时检查状态：`openspec status --change "name"`

## 反馈

这很粗糙。这是故意的——我们在学习什么是有效的。

发现了 Bug？有想法？加入我们的 [Discord](https://discord.gg/YctCnvvshC) 或在 [GitHub](https://github.com/Fission-AI/openspec/issues) 上提交 issue。
